Getting Started (RREF)
======================

This page details how to get started with photonic_circuit_solver. This page covers the RREF function and the photonic circuit solving algorithm.

This is entire codebase relies on the Stabilizer class, so if you haven't already read that page first.

Installation
------------
To install photonic_circuit_solver and use the rref functions and supplemental functions, you will need photonic_circuit_solver installed in an environment with the following packages:

* Python 3.11 or superior
* NumPy
* Qiskit (optional)
* Matplotlib (optional)
* SymPy (optional)

As in Stabilizer, the core computation is all done using NumPy as native python data types, all optional packages are for visual and style utility. Qiskit is needed for any functions that output qiskit circuits, Matplotlib is needed for any plotting functions, and SymPy is needed for functions in the supplemental functions.

RREF Gauge Choice
-------------------

In the Stabilizer section, we noted that the choice of generators for representing a stabilizer state is not unique. However, given a choice of generators, there is a way to bring it into a form that is similar to the upper triangular form of the RREF linear operation on matrices. This protocol is called the RREF algorithm, and further details can be found at https://doi.org/10.1088/1367-2630/7/1/170.

Note that even fixing a set of generators, the RREF gauge is still not unique. However, it does have some useful properties for our purposes.

First, fix some order of your generators. This is done inherently by the ``Stabilizer`` class since the tableau is a matrix with ordered rows.

To bring a set of stabilizers into RREF gauge, we note that we have N columns and K rows. For the purposes of this package, since the Stabilizer class enforces pure states, K = N, although this is not necessarily true for broader uses of the algorithm.

We also have an active region, denoted by the column NL and the row KU.

We start by setting NL = 1 and inspect the first column, and look at all the Paulis in the first column, i.e. inspecting the first entry in every generator. There should be one of two cases, there are only identities and one specific Pauli, or identities and at least two Paulis.

If we're in case 1, reorder the generators such that a generator with a non-identity Pauli are in row 1, and set KU = 1. Then, for all rows k such that k>KU, if the first entry of that generator is a non-identity Pauli, multiply that generator by the first generator and replace it.

In the code, this is done via the ``row_add`` method of the Stabilizer class.

If we're in case 2, reorder the generators such that a generator with the non-identity Paulis are in rows 1 and 2, and ensure that those Paulis differ. Set KU = 2, and for all k>KU, inspect the corresponding generator. If the first Pauli is an identity, do nothing. If it matches the Pauli in row 1, multiply them together and replace the kth generator with that, and similar with row 2. If it is the third pauli, multiply by both row1 and row2 and replace the kth generator with the new generator.

Then set NL=1, and follow the same steps (only inspecting Paulis for rows greater than the previous KU). If the column has only identities (which wasn't possible for column 1 but is possible afterwards), don't alter KU and just set NL+=1

Let's see the package implement this.

.. code-block:: python

    from photonic_circuit_solver import *
    state = Stabilizer(edgelist = [[0,1],[1,3],[3,2],[2,0],[1,2]])
    state.stabilizers()

returns

::

    ['XZZI', 'ZXZZ', 'ZZXZ', 'IZZX']

Now lets implement the RREF procedure. If you do the RREF procedure by hand, you should notice all we need to do is multiply row 2 into row 3, and then the generators will be in RREF gauge.

And as expected, following the above code with

.. code-block:: python

    rref(state)
    state.stabilizers()

returns

::
    
    ['XZZI', 'ZXZZ', 'IYYI', 'IZZX']

As expected.